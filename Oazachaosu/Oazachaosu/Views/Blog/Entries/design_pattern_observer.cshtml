@{
  ViewBag.Title = "Obserwator - wzorce projektowe";
}

<p>
  &emsp;Programowanie zorientowane obiektowo sprzyja rozważaniom na temat stanów obiektów. Konsekwencją rozdrobienia struktury danych na obiekty jest znalezienie sposobu na komunikacje pomiędzy nimi,
  tak aby obiekty znały nawzajem swoje stany. Jednak aby zachować jak największe odseparowanie obiektów powiązanie nie może być ścisłe, ponieważ zmniejsza to możliwość ponownego wykorzystania klas. <br>
  Przykładem mogą być wszystkie listenery z obiektów z pakietu swing Javy. Bardziej przyziemnym przykładem może być zwykły timer, który co określony czas musi powiadomić zainteresowanych o tym, że ten
  czas minął. Idealnym rozwiązaniem takiego zagadnienia jest wprowadzenia wzorca obserwator. Obserwator tworzy relacje jeden do wielu (w przypadku szczególnym może to być relacja jeden do jeden).
  Głównymi elementami potrzebne do wprowadzenia tego wzorca są dwa elementy - podmiot i obserwator. Podmiotem jest obiekt który zmienia swój stan i informuje o tym swoich obserwatorów (w szczególnym
  przypadku pojedynczego obserwatora).
</p>

<h3>Wykorzystanie</h3>

<p>
  &emsp;Istnieje potrzeba jednokierunkowej komunikacji pomiędzy luźno powiązanymi obiektami. Jeden ma obiektów wysyłać swój stan, drugi potrzebuje informacji o tym stanie i jego zmianie. Wzorzec
  wykorzystamy również w przypadku kiedy wymagana jest informacja o zmodyfikowaniu stanu danego obiektu i nie wiadomo ile obiektów trzeba powiadomić o tym. W najbardziej skrajnym przypadku może być
  wymagana zmiana ilości obserwatorów w trakcie działania programu.
</p>

<h3>Elementy Obserwatora</h3>

<ul>
  <li>
    <b>ISubject</b> - interfejs podmiotu, którego stan jest ważny dla innych obiektów. Zawiera on trzy funkcje dodanie, usunięcia i powiadomienia obserwatorów.
  </li>
  <li>
    <b>IObserver</b> - interfejs obserwatora. Zadeklarowana jest pojedyncza metoda uaktualnienia która będzie wywoływana w czasie zmiany stanu podmiotu.
  </li>
  <li>
    <b>ConcreteSubject</b> - klasa konkretnego podmiotu implementująca interfejs <b>ISubject</b>. Podczas zmiany stanu tego obiektu będzie rozsyłana informacja o tej zmianie. Przechowuje listę
    swoich obserwatorów.
  </li>
  <li>
    <b>ConcreteObserver</b> - klasa konkretnego obserwatora implementująca interfejs <b>IObserver</b>. Obiekty tej klasy wymagają informacji o zmianie stanu obiektów klasy <b>ConcreteSubject</b>.
  </li>
</ul>

<h3>Komunikacja</h3>

<p>
  &emsp;Wykorzystując wzorzec Obserwatora sami musimy zadecydować kiedy podmiot ma powiadamiać swoich obserwatorów. Nie każda zmiana jest na tyle istotna, że należy to robić. W czasie wywoływania
  funkcji powiadamiającej możemy przekazać w niej konkretne parametry (np. te które się zmieniły) lub przesyłać cały obiekt podmiotu (jest to jednak nadmiarowe wysyłanie danych które w większości
  nie będą wykorzystane). Ten sposób komunikacji nazywany jest <b>push model</b>. <br>
  Innym sposobem (<b>pull model</b>) jest przechowywanie przez obserwatorów referencji do podmiotu i w czasie powiadamiania obserwator sam wyciąga z podmiotu interesujące go informacje. Również i
  to jest mało efektywne ze względu na dwustopniową komunikacje (powiadomienie i wyciągnięcie danych), co może spowodować trudne do zlokalizowania problemy w systemach wielowątkowych - zanim pobierzemy
  dane z podmiotu, nastąpi zmiana stanu.<br>
</p>

<h3>Przykład</h3>

<p>
  Przykładem będzie troszeczkę bezużyteczny programik, ponieważ można było zastąpić obserwatora i włączyć go do klasy ConcreteSubject. Lepiej wykorzystany ten wzorzec będzie w większych projektach.<br />
  Interfejs obserwatora. W tym przypadku chcemy tylko informacji, że następuje wylosowanie liczby większej od 50. Jednak moglibyśmy przekazać tą liczbę w funkcji i już wiedzielibyśmy coś więcej
  o zdarzeniu.
</p>

<pre><code class="java">package pl.oazachaosu.designpatterns;
public interface IObserver {
    void update();
}</code></pre>

<p>
  Przykładowy konkretny obserwator. RandomObserver wypisuje jedynie powiadomienie na ekran.
</p>

<pre><code class="java">package pl.oazachaosu.designpatterns;
public class RandomObserver implements IObserver {
    @@Override
    public void update() {
        System.out.println("Powiadomiony");
    }    
}</code></pre>

<p>
  Interfejs podmiotu zawiera w sobie trzy wyżej przedstawione metody. W wyjątkowych sytuacjach nie jest konieczne implementacja tego interfejsu. Tak naprawdę wystarczyłoby stworzenie odpowiedniej
  listy w klasie i stworzenie funkcji do dodawania obserwatorów. Wynik byłby taki sam.
</p>

<pre><code class="java">package pl.oazachaosu.designpatterns;
public interface ISubject {
    void addObserver(IObserver pObserver);
    void removeObserver(IObserver pObserver);
    void notifyChange();
}</code></pre>

<p>
  Klasa konkretnego podmiotu. Przechowuje ona wszystkich obserwatorów w liście <b>observerList</b>, możemy dodawać i usuwać ich, a powiadomienie następuje poprzez wywołanie metod <b>update</b> w
  metodzie <b>notifyChange()</b>.
</p>

<pre><code class="java">package pl.oazachaosu.designpatterns;
import java.util.ArrayList;
import java.util.Random;
public class ConcreteSubject implements ISubject {
    private final ArrayList&lt;iobserver&gt; observerList;
    public ConcreteSubject() {
        observerList = new ArrayList<>();
    }
    @@Override
    public void addObserver(IObserver pObserver) {
        observerList.add(pObserver);
    }
    @@Override
    public void removeObserver(IObserver pObserver) {
        observerList.add(pObserver);
    }
    @@Override
    public void notifyChange() {
        for (IObserver item : observerList) {
            item.update();
        }
    }
    public void run() {
        Random random = new Random();
        for (int i = 0; i < 100; i++) {
            if(random.nextInt(100) > 50){
                notifyChange();
            }
        }
    }
}</code></pre>

<p>
  Klasa główna w której tworzymy wszystkie obiekty potrzebne do sprawdzenia naszego kodu. Po pierwszym wywołaniu metody <b>run()</b>, następuje wypisanie na ekranie powiadomienia. Po usunięciu obserwatora
  powiadomienie nie pokazują się.
</p>

<pre><code class="java">package pl.oazachaosu.designpatterns;
public class Main {
    public static void main(String[] args){
        ConcreteSubject subject = new ConcreteSubject();
        IObserver observer = new RandomObserver();
        subject.addObserver(observer);
        subject.run();
        subject.removeObserver(observer);
        subject.run();
    }
}</code></pre>

<h3>Plusy</h3>
<p>
  &emsp;Przy pozostawieniu odseparowanych klas otrzymujemy możliwość komunikacji pomiędzy nimi. Powstaje możliwość zmiany obserwatorów w trakcie działania programu, bez zmiany podmiotu ani wcześniej
  dodanych obserwatorów. Sami obserwatorzy nie wiedzą o swoim istnieniu, jedynie podmiot wie jakich ma obserwatorów opartych o prosty interfejs. Dodatkowo podmiot nie zna konkretnej klasy obserwatora,
  która może się okazać zdecydowanie większa niż implementacja interfejsu <b>IObserver</b>.
</p>
<h3>Minusy</h3>
<p>
  &emsp;W zależności od tego jak został zaimplementowany wzorzec Obserwator pojawić się może problem z kaskadową aktualizacją obserwatorów. Kiedy obserwator może zmieniać stan podmiotu może dość do
  sytuacji zapętlenia powiadamiania. Jest to także konsekwencją tego, że poszczególni obserwatorzy nie wiedzą o swoim istanieniu. Istnieje jednak proste zabezpieczenie przed takim stanem rzeczy - podczas
  aktualizacji przekazywać parametry, które uległy zmianie - jednak, jest to ograniczenie możliwości tego wzorca.
</p>
<h3>Literatura</h3>
<ul>
  <li>Elisabeth Freeman, Eric Freeman, Bert Bates, Kathy Sierra - "Wzorce projektowe. Rusz głową!"</li>
  <li>Erich Gamma, Richard Helm, Ralph Johnson, John M. Vlissides - "Wzorce projektowe. Elementy oprogramowania obiektowego wielokrotnego użytku "</li>
</ul>
