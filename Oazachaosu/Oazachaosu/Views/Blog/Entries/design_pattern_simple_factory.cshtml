@{
  ViewBag.Title = "Prosta Fabryka - wzorce projektowe";
}
<p>
  &emsp;Prosta fabryka (ang. simple factory) nie jest pełnoprawnym wzorcem projektowym. Można powiedzieć, że jest zamknięciem procesu tworzenia w oddzielną klasę, która pozwala nam tworzyć pewną rodzinę produktów. Nie mniej jednak, jest to bardzo często wykorzystywana technika. Nie zmusza ona do tworzenia niezliczonych ilości interfejsów i klas, a jedynie (w ekstremalnym wypadku) jedną klasę z jedną metodą.
</p>
<h3>Wykorzystanie</h3>
<p>
  &emsp;Z prostej fabryki korzystamy kiedy chcemy wydzielić proces tworzenia obiektu, a jedynie zwrócić stworzony obiekt. Do obiektu odwołujemy się tylko przez wspólny interfejs.

</p>
<h3>Elementy </h3>
<ul>
  <li>
    <b>IProduct</b> - interfejs, który będzie nam dostarczał określony typ dla naszych produktów.

    <pre><code class="java">public interface IProduct {
    //wnętrze interfejsu
    }
}</code></pre>

  </li>
  <li>
    <b>ConcreteProduct</b> - klasa implementująca interfejst <b>IProduct</b>. Jest to element całej rodziny produktów, który będziemy mogli stworzyć w naszej prostej fabryce.

    <pre><code class="java">public class Produkt1 implements IProduct {
    //definicja produktu 1
    }
}</code></pre>

    <pre><code class="java">public class Produkt2 implements IProduct {
    //definicja produktu 2
    }
}</code></pre>

  </li>
  <li>
    <b>ProductFactory</b> - klasa prostej fabryki. Zawiera ona metodę wytwórczą, która przyjmuje pewien parametr identyfikujący nasze produkty.

    <pre><code class="java">public class ProduktFactory {
    public IProduct createProduct(int number){
      switch(number){
        case 1:
          return new Product1();
        case 2:
          return new Product2();
        default:
          return null;
      }
    }
}</code></pre>

  </li>
</ul>

<h3>Przykład</h3>
<p>Przypuśćmy, że mamy prosty kod klienta - tworzenie obiektu typu <b>ITank</b> w zależności od parametru początkowego <b>choice</b> (może on być przekazywany z standardowego wejścia, albo jako parametr uruchominiowy). W zależności od tego jaki on jest taki obiekt jest tworzony.</p>
<pre><code class="java">public class Main1 {
    public static void main(String[] args){
        ITank tank;
        String choise = "sherman";
        if(choise.equals("sherman")){
            tank = new ShermanTank();
        }else{
            tank = new TigerTank();
        }
        tank.shoot();
    }
}</code></pre>
<p>Jednak wraz z rozwojem aplikacji zwiększa się nam liczba dostępnych czołgów. Zgodnie z pewną zasadą projektowania obiektowego, która mów aby oddzielać kod, który ulega zmianie od tego który jest stały powinniśmy wydzielić tworzenie do oddzielnej klasy - naszej fabryki.</p>
<pre><code class="java">public class TankFactory {
    
    public ITank createTank(String pChoice){
        switch (pChoice.toLowerCase()) {
            case "sherman":
                return new ShermanTank();
            case "tiger":
                return new TigerTank();
            case "t34":
                return new T34Tank();
            default:
                return null;
        }
    }
    
}</code></pre>
<p>Kod po stronie klienta:</p>
<pre><code class="java">public class Main2 {
    public static void main(String[] args){
        TankFactory factory = new TankFactory();
        ITank tank;
        String choice = "sherman";
        tank = factory.createTank(choice);
        if(tank != null){
            tank.shoot();
        }
    }
}</code></pre>
<h3>Plusy</h3>
<p>
  &emsp;Największym plusem jest oddzielenie zmiennego kodu od niezmiennego. Oczywiście nie chodzi tutaj, że kod klienta nie może się zmienić. Wszystko może się zmienić, jednak możemy przewidzieć, czy rozwój aplikacji spowoduje zmianę naszego kodu czy nie. Jeżeli odpowiedź jest pozytywna, należy zastanowić się nad podziałem. Równie duża korzyścią płynącą z zastosowania tej techniki jest możliwość wykorzystania tego kodu tworzącego wiele razy. Jeżeli czołg miałby być tworzony raz lub dwa razy to nie byłoby większego problemu z poprawianiem kodu w kilku miejscach, ale przy dużych projektach tych miejsc może być więcej. Ponad to, może się zdarzyć, że przy projekcie uczestniczy wielu programistów. Przy rozbudowie może po prostu nastąpić przeoczenie i powstania trudnego do wytropiania problemu.
</p>
<h3>Minusy</h3>
<p>
  &emsp;Prosta fabryka jest na tyle małą zmianą, że ciężko wytknąć jakieś minusy. Możemy go stosować niewielkiej hierarchii klas. W przypadku czegoś większego lepszym wyborem byłoby wykorzystanie większego kombajnu, czegoś w stylu metody fabrykującej albo fabryki abstrakcyjnej.
</p>
<h3>Literatura</h3>
<ul>
  <li>Elisabeth Freeman, Eric Freeman, Bert Bates, Kathy Sierra - "Wzorce projektowe. Rusz głową!"</li>
</ul>
