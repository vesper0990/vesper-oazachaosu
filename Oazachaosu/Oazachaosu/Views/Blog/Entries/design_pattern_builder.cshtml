
@{
    ViewBag.Title = "Budowniczy - wzroce projektowe";
}

<p>
  Tworzenie obiektów w naszym kodzie jest nieuniknionym elementem. Jednak istnieją specyficzne sytuacje, kiedy trzeba takie tworzorzenie oddelegować do innych jednostek. Przypuśćmy, że mamy dość
  skomplikowany obiekt, który posiada wiele pól - dla przykładu będzie to klasa Car. Samochód możemy opisać za pomocą wielu elemenów, od wyglądu, przez wyposażenie, do podzespołu silnika.
  Gdyby chcielibyśmy za każdeym razem uzupełniać wszystkie te elementy w konstruktorze musiałbym on wyglądać mniej więcej tak:
  
  <pre><code class="java">public Car(int color, List&lt;Wheel&gt; wheels, boolean spoiler, ... boolean airCondition, boolean heatSit, ... , float engineCapacity, int horsePower){
    this.color = color;
    this.wheals = wheels;
    //...
    this.airCondition = airCondition;
    this.heatSit = heatSit;
    //...
    this.engineCapacity = engineCapacity;
    this.horsePower = horsePower;
}</code></pre>
  
  Samo uzupełnienie takiego konstruktora przyprawiłoby niejednego o ból głowy. A co w przypadku kiedy trzeba byłoby stworzyć dodatkowe parametry, które pojawiłby się w przyszłości? W każdym miejscu wywołania 
  konstruktora trzeba byłoby poprawić ilość i kolejność parametrów. Na przeciw temu problemowi powstał wzorzec <b>Budowniczy</b> (Builder). Na samym początku umożliwi on stworzenie 
  obiektów bez korzystania z tak skomplikowanych konstruktorów, a na pewno nie będziemy korzystać z nich za często. W zależności od konieczności będziemy mogli dorobić do niego kolejne 
  ficzery, które uprzyjemnią nam zadanie lub stworzą dodatkowe zabezpieczenia.
</p>

<h3>
  Wykorzystanie
</h3>

<p>
  Podstawowymi miejscami, które skłaniają do wykorzystania <b>Budowniczego</b>, są to miejsca gdzie wymagamy oddzielenie tworzenia złożonego obiektu od jego składników i sposobu ich składania.
  Inną możliwością jest koniczność stworzenia serii różnych reprezentacji tej samej klasy. Tak jak napisałem wyżej, w zależności od tego w jaki sposób "przyozdobimy" nasze Budowniczego
  to możemy uzyskać inne plusy stosowania tego wzroca. W sieci można również znaleźć informację, że Budowniczy powinien dotyczyć jedynie niezmiennych obiektów. Będzie to wynikało
  z samej implementacji wzroca - przedstawię to później.
</p>

<h3>Elementy Budowniczego</h3>

<ul>
  
  <li>
    <b>Builder</b> - jest to jedyna klasa, która wchodzi w skład tego wzorca projektowego. To co jeszcze będzie zawierał zależy od tego co będzie robił, jednak podstawową metodą, która poniekąd 
    jest wymagana, jest metoda <code>build()</code>. Będzie się ona zajmowała wywoływaniem konstruktora i zwracaniem tworzonego obiektu.
  </li>

</ul>

<h3>Pryzkład</h3>

<p>
  Za przykład posłuży nam klasa <code>Car</code> przedstawiona we wprowadzeniu. Dla samej idei wystarczą również te parametry, które wystepują już w konstruktorze.<br/>
  Na poczatku musimy spawdzić jak wyglądają nasze klasy bez wprowadzenia wzorca. Klasa <code>Car</code> wymaga istnienia klasy <code>Wheele</code>, więc poniżej umieszczam
  przykladowe impelementacje tych klas. Wszystkie pola są prywatne, stworzony jest konstruktor który wymaga podania określonych parametrów, a poniżej gettery i settery do wszytkich pól.
  

</p>

<p>Klasa <code>Car</code></p>
<pre><code class="java">public class Car{
    private int color;
    private ArrayList&lt;Wheel&gt; wheels;
    private boolean spoiler;
    private boolean ariCondition;
    private boolean heatSit;
    private float engineCapacity;
    private int horsePower;
    public Car(int color, ArrayList&lt;Wheel&gt; wheels, boolean spoiler, boolean ariCondition, boolean heatSit, float engineCapacity, int horsePower) {
        this.color = color;
        this.wheels = wheels;
        this.spoiler = spoiler;
        this.ariCondition = ariCondition;
        this.heatSit = heatSit;
        this.engineCapacity = engineCapacity;
        this.horsePower = horsePower;
    }
    public int getColor() {
        return color;
    }
    public void setColor(int color) {
        this.color = color;
    }
    public ArrayList&lt;Wheel&gt; getWheels() {
        return wheels;
    }
    public void setWheels(ArrayList&lt;Wheel&gt; wheels) {
        this.wheels = wheels;
    }
    public boolean isSpoiler() {
        return spoiler;
    }
    public void setSpoiler(boolean spoiler) {
        this.spoiler = spoiler;
    }
    public boolean isAriCondition() {
        return ariCondition;
    }
    public void setAriCondition(boolean ariCondition) {
        this.ariCondition = ariCondition;
    }
    public boolean isHeatSit() {
        return heatSit;
    }
    public void setHeatSit(boolean heatSit) {
        this.heatSit = heatSit;
    }
    public float getEngineCapacity() {
        return engineCapacity;
    }
    public void setEngineCapacity(float engineCapacity) {
        this.engineCapacity = engineCapacity;
    }
    public int getHorsePower() {
        return horsePower;
    }
    public void setHorsePower(int horsePower) {
        this.horsePower = horsePower;
    }
}</code></pre>

<p>Klasa <code>Wheel</code></p>
<pre><code class="java">class Wheel{
    private float diameter;
    private float width;
    
    public Wheel(float diameter, float width){
        this.diameter = diameter;
        this.width = width;
    }
    public float getDiameter() {
        return diameter;
    }
    public void setDiameter(float diameter) {
        this.diameter = diameter;
    }
    public float getWidth() {
        return width;
    }
    public void setWidth(float width) {
        this.width = width;
    }
}</code></pre>

<p>Przykładowe wykorzystanie tych klas, które nie ma żadnego rzeczywistego wykorzystania jest takie:</p>

<pre><code class="java">ArrayList&lt;wheel&gt; wheels = new ArrayList<>();
Car car = new Car(0, wheels, true, true, true, 0, 0);</code></pre>

<p>
  Programista widząc konstruktor klasy <code>Car</code> nie ma żadnego pojęcia co oznacza drugie <code>true</code>. Możemy to wytłumaczyć, że jak będzie chciał się dowiedzieć
  zawsze może przeczytać w dokumentacji albo wejść do definicji klasy i sprawdzić. Jednak można tak tłumaczyć jeżeli parametrów jest kilka, 2 bądź 3. Jeżeli mamy większą liczbę
  paremetrów musimy zastanowić się czy nie lepszym rozwiązaniem byłby inne rozwiązanie. Ponad to, zastanówmy się, czy nie możemy stworzyć kilku parametów domyślnych, np silniki
  w tym modelu będą tylko o jednej pojemności i mocy, a jedynie dla specjalnych klientów montowane będą mocniejsze jednostki. W takiej sytuacji musimy stworzyć dodatkowy 
  konstruktor albo nienatrualnie korzystać z setterów po stworzeniu obiektu. Tak więc, możemy już wytknąć kilka problemów w tym rozwiązaniu.<br />
  Przejdźmy teraz do rozwiązania z wykorzystaniem Budowniczego. Najpierw przygotujmy klase <code>Car</code> do tego aby był sens stosowania wzroca. Musimy usunąć settery, aby
  pola obiektu były niezmienne oraz usuniemy nasz skomplikowany konstuktor.
</p>

<pre><code>class Car{
    private int color;
    private ArrayList&lt;wheel&gt; wheels;
    private boolean spoiler;
    private boolean ariCondition;
    private boolean heatSit;
    private float engineCapacity;
    private int horsePower;
    public int getColor() {
        return color;
    }
    public ArrayList&lt;wheel&gt; getWheels() {
        return wheels;
    }
    public boolean isSpoiler() {
        return spoiler;
    }
    public boolean isAriCondition() {
        return ariCondition;
    }
    public boolean isHeatSit() {
        return heatSit;
    }
    public float getEngineCapacity() {
        return engineCapacity;
    }
    public int getHorsePower() {
        return horsePower;
    }
    
}</code></pre>

<p>
  Przyszła pora na implementacje Buildera. Musi on się składać z takich pól z jakich składa się klasa <code>Car</code>, ponieważ musi wiedzieć z czego skłąda się obiekt który tworzy.
  Dodatkowo będzie zawierał settery, ale nie będą to settery, które usuneliśmy przed chwilą z klasy <code>Car</code>. Bedą one zwracały obiekt <code>this</code> budowniczego. 
  Dzieki takiemu zabiegowi zyskamy możliowść kolejkowych wywolań setterów. Na samym końcu będziemy tworzyli obiekt w metodzie <code>build</code>.<br/>
  Co do samej implementacji metody <code>build</code> istnieje kilka możliwości. Możemy wykorzystać konstruktor wcześniej zaprezentowany, ale częściej spotyka się stworznenie
  konstruktora który będzie przyjmował jako parametr obiekt naszego buildera.
</p>

<pre><code class="java">class CarBuilder{
    private int color;
    private ArrayList&lt;wheel&gt; wheels;
    private boolean spoiler;
    private boolean ariCondition;
    private boolean heatSit;
    private float engineCapacity;
    private int horsePower;
    
    public CarBuilder setColor(int color){
        this.color = color;
        return this;
    }
    public CarBuilder setWheels(ArrayList&lt;wheel&gt; wheels){
        this.wheels = wheels;
        return this;
    }
    
    public CarBuilder setSpoiler(boolean spoiler){
        this.spoiler = spoiler;
        return this;
    }
    
    public CarBuilder setAirCondition(boolean ariCondition){
        this.ariCondition = ariCondition;
        return this;
    }
    
    public CarBuilder setheatSit(boolean heatSit){
        this.heatSit = heatSit;
        return this;
    }
    
    public CarBuilder setEnginCapacity(float engineCapacity){
        this.engineCapacity = engineCapacity;
        return this;
    }
    
    public CarBuilder setHorsePower(int horsePower){
        this.horsePower = horsePower;
        return this;
    }
    public Car build(){
        return new Car(this);
    }
}</code></pre>

<p>
  Teraz pozostało nam stworzenie konstruktora. Jeżeli jednak spróbujemy odwołac się do pól <code>CarBuildera</code> w konstruktorze <code>Car</code>, skończy się to błędem kompilacji,
  ponieważ pola <code>CarBuildera</code> oznaczone są modyfikatorem <code>private</code>. Najbardziej oczywistym rozwiązaniem byłoby stworzenie getterów, albo ustawienie pól na 
  <code>public</code>, jednak wtedy byłboby to tworzenie nadmiarowego kodu. Najlepszym sposobem jest stworzenie klasy <code>CarBuilder</code> jak klasy wewnętrznej klasy <code>Car</code>.
</p>

<pre><code class="java">class Car {
    private int color;
    private ArrayList&lt;wheel&gt; wheels;
    private boolean spoiler;
    private boolean airCondition;
    private boolean heatSit;
    private float engineCapacity;
    private int horsePower;
    public Car(CarBuilder builder) {
        this.color = builder.color;
        this.wheels = builder.wheels;
        this.spoiler = builder.spoiler;
        this.airCondition = builder.airCondition;
        this.heatSit = builder.heatSit;
        this.engineCapacity = builder.engineCapacity;
        this.horsePower = builder.horsePower;
    }
    class CarBuilder {
        private int color;
        private ArrayList&lt;wheel&gt; wheels;
        private boolean spoiler;
        private boolean airCondition;
        private boolean heatSit;
        private float engineCapacity;
        private int horsePower;
        public CarBuilder setColor(int color) {
            this.color = color;
            return this;
        }
        public CarBuilder setWheels(ArrayList&lt;wheel&gt; wheels) {
            this.wheels = wheels;
            return this;
        }
        public CarBuilder setSpoiler(boolean spoiler) {
            this.spoiler = spoiler;
            return this;
        }
        public CarBuilder setAirCondition(boolean airCondition) {
            this.airCondition = airCondition;
            return this;
        }
        public CarBuilder setheatSit(boolean heatSit) {
            this.heatSit = heatSit;
            return this;
        }
        public CarBuilder setEnginCapacity(float engineCapacity) {
            this.engineCapacity = engineCapacity;
            return this;
        }
        public CarBuilder setHorsePower(int horsePower) {
            this.horsePower = horsePower;
            return this;
        }
        public Car build() {
            return new Car(this);
        }
    }
    public int getColor() {
        return color;
    }
    public ArrayList&lt;wheel&gt; getWheels() {
        return wheels;
    }
    public boolean isSpoiler() {
        return spoiler;
    }
    public boolean isAirCondition() {
        return airCondition;
    }
    public boolean isHeatSit() {
        return heatSit;
    }
    public float getEngineCapacity() {
        return engineCapacity;
    }
    public int getHorsePower() {
        return horsePower;
    }
}</code></pre>
