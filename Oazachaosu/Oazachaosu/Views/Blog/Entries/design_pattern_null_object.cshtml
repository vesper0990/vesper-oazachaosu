@{
  ViewBag.Title = "Null object - wzorce projektowe";
}

<p>
  &emsp;Domyślną wartością dla jakiejkolwiek referencji jest wartość null. Wartość tak prosta, że aż dziwne ile problemów może spowodować.
  Przez swojego wynalazcę nazwana "billion-dollar mistake". Czy rzeczywiście był to błąd w profesji? Czy można to jakoś naprawić? Niewątpliwie
  wszystkim kiedyś przydażyło się uzystkać NullPointerException. A gdyby istniała możliwość zaniedbania tego wyjątku? Taką drogę możemy obrać
  wykorzystując wzorzec <b>Null object</b>.
</p>

<h3>Wykorzystanie</h3>

<p>
  &emsp;Podstawowym zastosowaniem tego wzorca jest zapwenienie pewnego obiektu dla sytuacji kiedy referencja pozostaje pusta. Dzięki temu
  możemy bez przeszkód wywolywać dostępne metody i odnosić się do pól danego obiektu, bez zmartwienia uzyskania NullPointerExceptiona.
  Kolejnym zastosowaniem jest możliwość stworzenia pewnego zachowania "nic nie robienia". W niektórych przypadkach lepiej uzyskać jest "nic nie robienie",
  niż wyrzucenie wyjątka. Na pierwszy rzut oka przez takie zachowanie powstaje nowy problem: co jeśli uzyskamy <b>Null object</b>, a my nie będziemy sprawdzali
  czy rzeczywiście taka wartość została zwrócona. W normalnym przypadku jak było źle to uzyskiwalismy wyjątek i poprawialiśmy kod tak aby było dobrze. Taraz
  wszystko działa bez zarzutu, ale wynik naszego działania nie jest zgodny z naszymi oczekiwaniami.
  W przypadku tego wzorca trochę więcej spada na ręce programisty. To my musimy wiedzieć kiedy sprawdzić czy uzyskujemy <b>Null object</b>, a kiedy
  poprawny obiekt - przykład później.
</p>

<h3>Elementy Null objecta</h3>

<ul>

  <li>
    <b>IInterface</b> - podstawą jest jakaś abstrakcja, która będzie dotyczyła konkretnego działania. Wychodząc od zasad SOLID, każde nasze działanie
    powinno zaczynać się od abstrakcji, więc i każda nasza klasa powinna dziedziczyć po jakimś interfejsie - własnie tym interfejsie

    <pre><code class="java">package pl.oazachaosu.designpatterns;
public interface IInterface {
    void doSomething();
}</code></pre>

  </li>
  <li>
    <b>ConcreteImplementation</b> - klasa implementująca interfejs <b>IInterface</b>. To jest właśnie ta klasa która wystepowała by w tradycyjnym podejściu.

    <pre><code class="java">package pl.oazachaosu.designpatterns;
public class ConcreteImplementation implements IInterface {
    public void doSomething(){
      //cos tutaj robimy
    }
}</code></pre>

  </li>
  <li>
    <b>NullImplementation</b> - to jest <b>Null object</b>. W tym przypadku różnice widzimy od razu, przy wywołaniu funkcji <b>doSomething()</b> nie uzyskamy nic więcej
    jak tylko wywołanie pustej metody.

    <pre><code class="java">package pl.oazachaosu.designpatterns;
public class NullImplementation implements IInterface {
    public void doSomething(){
      //tu nie robimy nic
    }
}</code></pre>

  </li>

</ul>

<h3>Przykład</h3>

<p>
  Przykład będzie jeden ale konkretny, on sam przekonał mnie do tego aby nie skreślać tego wzorca na samym poczatku. Zaczniemy od zdefiniowania iterfejsu, który będzie
  odpowiadł za przechowywanie pewnych danych o pliku.
</p>

<pre><code class="java">package pl.oazachaosu.designpatterns;
public interface IFile{
  String getContent();
  String getName();
  int getLengthContent();
  DateTime getCreateDate();
}</code></pre>

<p>
  Mając już zdefiniowany interfejs możemy przystąpić do implementacji konkretnego obiektu, który będzie zawierał wszystkie interesujące nas elementy.
</p>

<pre><code class="java">package pl.oazachaosu.designpatterns;
public class File implements IFile {
  private String content; 
  private String name;
  private int lengthContent;
  private DateTime createDate;
  
  public File(String content, String name, int lengthContent, DateTime createDate){
    this.content = content;
    this.name = name;
    this.lengthContetn = lengthContent;
    this.createDate = createDate;
  }

  public String getContent(){
    return content;
  }

  public String getName(){
    return name;
  }
  public int getLengthContent(){
    return lengthContent;
  }
  public DateTime getCreateDate(){
    return createDate;
  }
}</code></pre>

<p>
  Do stworzenia obiektu używamy tutaj konstruktora, ale równie dobrze nadały by się settery, które trzeba zdefiniować w interfejsie <b>IFile</b>. Równolegle do 
  istniejacej klasy File, powinna nastąpić implementacja wzroca <b>Null object</b>. W tym celu tworzymy osobną klasę <b>NullFile</b>.
</p>

<pre><code class="java">package pl.oazachaosu.designpatterns;
public class NullFile implements IFile {
  public String getContent(){
    return "";
  }
  public String getName(){
    return "";
  }
  public int getLengthContent(){
    return -1;
  }
  public DateTime getCreateDate(){
    return new DateTime(1900, 1, 1); //jakaś defaultowa data
  }
}</code></pre>

<p>
  Stworzyliśmy już bazę którą możemy wykorzystywać w innych klasach. Przypuścmy że mamy jakaś klase która będzie zajmowała się wczytywaniem plików z dysku.
  Nic konkretnego nie musimy o niej wiedzieć wazna jest tylko metoda pobierająca plik.
</p>

<pre><code class="java">public IFile getFile(String path){
  //tutaj następuje pobranie pliku z dysku.
  //w przypadku np. wyjątku lub braku pliku zwracany jest nullFile.
}</code></pre>

<p>
  Tutaj przykładowe wykorzystanie funckji pobierającej
</p>

<pre><code class="java">IFile file = uploader.getFile("mojplik.txt");
System.out.println(file.getContent());</code></pre>


<p>
  Teraz zaczyna się magia. W przypadku gdybyśmy zwracali zwykłego nulla od razu wiedzielibyśmy, czy mamy dane pliku czy nie. Dostając <code>NullPointerException</code>
  wiemy, że coś poszło nie tak. Tradycyjnym zabezpieczeniem takiej sytuacji jest <code>if</code>.
</p>

<pre><code class="java">IFile file = uploader.getFile("mojplik.txt");
if(file != null){
  System.out.println(file.getContent());
}</code></pre>

<p>Teraz wiemy, że jest to bezpieczny kod. Jednak istnieją sytuacje które nie wymagają od nas sprawdzania takich sytuacji - pod warunkiem, że zabezpieczymy funkcję
  <code>getFile(String path)</code> przed zwracaniem <code>null</code>, przez zastosowanie <b>Null object</b>. Dla przykładu:
</p>

<pre><code class="java">IFile file = uploader.getFile("mojplik.txt");
if(file.getContent().contains("wzorzec")){
  //wykonuje coś ważnego
}
</code></pre>

<p>
  W takim przypadku bez przeszkód możemy wykonać ten kod. Jeżeli <code>getFile</code>, zwróci nam <code>NullFile</code>, to uzyskamy ten sam efekt jak
  sprawdzenie czy uzyskaliśmy <code>nulla</code>. Oczywiście gdybyśmy chceli wypisać zawartość pliku to nie ominie nas to sprawdzenie, ale przez takie 
  postepowanie uzykujemy zbiór operacji które nie wymagają tego.<br/>
  Bardzo wygodnym sposobem implementacji <b>Null objectu</b> jest implementacja jako <b>Singleton</b>. Do póki nie odniesiemy się do jego referencji do póty nie będzie on istniał.
  Jeżeli już zacznie, to będzie tylko jedna instancja w całym programie. Dodatkowo będziemy mogli porównywać referencje do tego samego miejsca w pamięci. Takie podejście
  zabezpiecza również nas, przed bardzo dziwnym dodaniem funkcji typu <code>isNull();</code>, która to ma zwracać <code>true</code> jeżeli obiekt reprezentuje <b>Null object</b>.
</p>

<h3>
  Podsumowanie
</h3>

<p>
  Wzorzec można lubić albo nienawidzić. Prawdziepowiedziawszy kiedy to piszę, dopiero co zrozumiałem zasadę działania tego wzorca na tym samym przykładzie. 
  <b>Null object</b> wydaje się być porzyteczny w niektórych przypadkach. Ile takich przypadków można uzyskać to jest sprawa tego jak dany interfejs jest przez nas
  eksploatowany. Tak czy inaczej nie można sprzeciwić się jego użyteczności.
</p>
